\chapter{Komunikacja międzyprocesowa}

Skrót IPC (ang. \textit{inter-process communication}) stosuje się do określenia zbioru sposobów komunikacji pomiędzy procesami systemu operacyjnego. Zbiór ten zawiera m. in. komunikację przez pliki, sygnały, potoki nienazwane, potoki nazwane, pamięć współdzieloną, gniazda, gniazda dziedziny Uniksa, systemy kolejkowe, przekazywanie wiadomości.

Każde rozwiązanie ma swoje wady i zalety. Niektóre działają w architekturze klient - serwer, inne współdzielą zasoby lub wykonują potrzebny program. Czynników poróżniających je jest wiele. To przede wszystkim czas komunikacji dla różnych rozmiarów wiadomości, ale także wspierane systemy operacyjne, możliwość komunikacji sieciowej, asynchroniczność, czy wsparcie dla wielu języków programowania.


\section{Komunikacja przez pliki}

Polega na zapisie pliku w miejscu dostępnym także dla innego procesu. Proces zapisujący dane tworzy plik lub modyfikuje istniejący, zaś proces czytający sprawdza istnienie i zawartość pliku. Metoda ta jest wspierana przez większość systemów operacyjnych.


\section{Sygnały}

Sygnały to ograniczona metoda komunikacji. Są to asynchroniczne powiadomienia, które można wysłać do innego procesu. Zazwyczaj nie stosuje się ich do przesłania danych, lecz jedynie do zakomunikowania pewnego zdarzenia. Proces odbierający może zaregować na wybrany sygnał w dowolny sposób, rejestrując funkcję do jego obsługi (ang. \textit{signal handler}).


\section{Potoki nienazwane}

Potoki nienazwane to sposób na komunikację jednokierunkową FIFO (ang. \textit{first in, first out} - pierwszy na wejściu, pierwszy na wyjściu). Zazwyczaj program tworzy taki potok, po czym uruchamia nowe procesy, które otrzymują dostęp do jego końca. Inną częstą aplikacją tej metody jest wykorzystanie w uniksowych powłokach systemowych. Przekierwane wtedy zostaje standardowe wyjście do standardowego wejścia kolejnego procesu (korzystając z symbolu \enquote{|})


\section{Potoki nazwane}

Potoki nazwane są rozszerzeniem nienazwanych. Różnią się jednak cyklem życia. Nie zostają zniszczone wraz z końcem procesu - istnieją one dopóki system jest uruchomiony. Można je też jawnie usunąć. Umożliwia to integrację procesów zapewniając bardziej luźne powiązanie niż w przypadku potoków nienazwanych.


\section{Pamięć współdzielona}

Pamięć współdzielona jest najszybszą z możliwych form komunikacji międzyprocesowej \cite{Ste92}. Polega wspólnym wykorzystywaniu przestrzeni adresowej. W przesyłaniu tych danych nie pośredniczy jądro systemu. Negatywna cecha tej metody to wymóg, aby programista sam zadbał o synchronizację procesów.


\section{Gniazda}

Gniazda (ang. \textit{socket}) umożliwiają dwustronną komunikację strumieniową poprzez interfejs sieciowy. Połączyć można procesy na tym samym komputerze, ale także dowolne będące w sieci. Metoda ta rzadko zachowuje granice wiadomości (ang. \textit{message boundaries}) tzn. transmitowane mogą być także fragmenty danych, czy w jednym buforze znaleźć można koniec poprzedniej i początek kolejnej wiadomości. O poprawne dzielenie komunikatów dbają protokoły wyższych warstw, np. prokół UDP (ang. \textit{User Datagram Protocol}) pozwala zachować granice wiadomości - są one wysyłanie pojedynczo, nigdy razem, nigdy nie są dzielone.


\section{Gniazda dziedziny Uniksa}

Gniazda dziedziny Uniksa są podobne do zwykłych gniazd, jednak cała komunikacja zachodzi wewnątrz jądra systemu operacyjnego, zamiast korzystać z sieci. W tej metodzie komunikacji, system plików jest używany jako przestrzeń adresowa. Procesy traktują gniazda dziedziny Uniksa jako i-węzły (ang. \textit{i-nodes}), więc wiele procesów może komunikować się poprzez otwieranie tego samego gniazda.


\section{Systemy kolejkowe}

Systemy kolejkowe umożliwiają odłożenie wiadomości na kolejkę, z której weźmie ją odbiorca. Dzięki temu procesy nie muszą wchodzić w bezpośrednią interakcję. Cechy kolejek komunikatów zależne są od implementacji. Na przykład standard \textit{System V} posiada zarówno blokujące, jak i nieblokujące funkcje odbioru wiadomości. POSIX oferuje ponadto możliwość rejestracji funkcji odbierającej powiadomienie, która zostanie wywołana, kiedy pojawi się nowy komunikat. Dzięki temu odbiorca nie musi odpytywać kolejki (ang. \textit{polling}), marnując czas procesora, ani zatrzymywać wykonywania programu.


\section{Przekazywanie wiadomości}

Programy moga także komunikować się kanałami niezarządzanym przez system operacyjny. Wysyłana jest wiadomość, a za uruchomienie odpowiedniego kodu odpowiada odbiorca i infrastruktura wspomagająca. Ten sposób jest często używany do budowania rozproszonych aplikacji. Komunikacja może być zarówno synchroniczna, jak i asynchroniczna. Abtrakcją innego procesu może być obiekt, ale też na przykład aktor (np. stosowany w Akkce\cite{akka} model aktorów). Przesyłanie wiadomości może być zaimplementowane w dowolny sposób.


\subsection{Zdalne wykonywanie procedur}

Zdalne wykonywanie procedur (RPC - ang. \textit{remote procedure call}) to protokół utworzony przez firmę Sun\cite{rpc} i dość popularny w systemach z rodziny Unix. Służy do uruchomienia procedury w innej przestrzeni adresowej (zazwyczaj na innym komputerze w sieci). Wywołanie niczym nie różni się od lokalnych funkcji, ukrywając przed programistą szczegóły zdalnej komunikacji. Abstrakcja ta ułatwia tworzenie oprogramowania, jednak zawsze należy pamiętać, że uruchamianie kodu na innej maszynie niesie za sobą narzut komunikacyjny i należy je ograniczać.


\subsection{Java RMI}

Java RMI (ang. \textit{Java remote method invocation})


\section{Tmp}

sygnały (ang. signals) – w niektórych systemach (jak np. DOS) znane jako przerwania programowe
semafory (ang. semaphores)
potoki nienazwane (ang. pipes) – znane też jako łącza komunikacyjne
potoki nazwane (ang. named pipes) – znane też jako nazwane łącza komunikacyjne
systemy kolejkowe (ang. message queues)
pamięć dzieloną (ang. shared memory) – znane też jako segmenty pamięci dzielonej (ang. shared memory segments)
gniazda dziedziny Uniksa (ang. Unix domain sockets)



https://en.wikipedia.org/wiki/Inter-process\_communication

wspoldzielony zasob:
File
Memory-mapped file

Signal; also Asynchronous System Trap	A system message sent from one process to another, not usually used to transfer data but instead used to remotely command the partnered process.




jeden system:
Message queue
Pipe
Shared memory


sieć:
Socket <- na nim kolejne protokoly (wlasny protokol na TCP, REST, websocket)
Message passing: distributed objects (CORBA), actor model (akka)
sync communication: REST


uruchomienie kodu natywnego (JNI)




TODO

